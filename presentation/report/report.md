---
## Front matter
title: "Доклад"
subtitle: "Программное решение обыкновенных дифференциальных уравнений"
author: "Демидова Екатерина Алексеевна"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Исследовать программные решения обыкновенных дифференциальных уравнений.

# Задачи

- Описать метод Эйлера
- Описать методы Рунге-Кутты
- Решить конкретную задачу Коши с помощью Octave, Julia и Python
- Сравнить результаты решений

# Общие сведения о дифференциальных уравнениях

Дифференциальным уравнением n-го порядка называется соотношение вида[@wiki:bash]:
$$F(x,y,y',y'',\dots,y^{(n)}) = 0$$
Решением дифференциального уравнения называется функция $y(x)$, которая обращает уравнение в тождество.

Системой дифференциальных уравнений n-го порядка называется система вида:

$$\begin{cases}
&x_1' = f_{1}(t,x_1,x_2,\dots,x_n) \\
&x_2' = f_{2}(t,x_1,x_2,\dots,x_n) \\
&\vdots \\
&x_n' = f_{n}(t,x_1,x_2,\dots,x_n) \\
\end{cases}$$

Произвольную систему дифференциальных уравнений любого порядка можно заменить некоторой эквивалентной системой уравнений первого порядка[]:
$$
y`(x) = f_k(x,y(x)),\tag{1}
$$
$$
y = {y_1,y_2,\dots,y_n}, f = {f_1,f_2,\dots,f_n}.
$$

Каждое дифференциальное уравнение, а также система, имеют бесконечное количество решений, которые различаются друг от друга только константами. Чтобы однозначно определить решение, необходимо указать дополнительные начальные или граничные условия. Количество таких условий должно соответствовать порядку дифференциального уравнения или системы. В зависимости от формы дополнительных условий, дифференциальные уравнения классифицируются на:

- задачу Коши, в случае если все дополнительные условия заданы в одной (чаще начальной) точке интервала;
- краевую задачу, в случае, когда дополнительные условия заданы на границах интервала

Существуют два типа методов решения дифференциальных уравнений: точные (аналитические) и приближенные (численные). Классы уравнений, для которых разработаны методы получения точных рещений, сравнительно узки и охватывают только малую часть возникающих на практике задач.

Численные методы - это алгоритмы вычисления приближенных значений искомого решения $y(x)$ уравнения (1) на некоторой равномерной выбранной сетке по $x$. Решение при этом получается в виде таблицы. Численные методы не позволяют найти общее решение системы (1). Они могут дать только частное решение, например решение задачи Коши(1)-(2)

# Метод Эйлера

Метод Эйлера играет важную роль в теории численных методов решения ОДУ, хотя и не часто используется в практических расчетах из-за невысокой точности.

Рассмотрим задачу Коши для дифференциального уравнения
$$
y'(x)=f(x,y) \tag{2}
$$
удовлетворяющее начальному условию
$$
y(x_0) = y_0 \tag{3}
$$

Требуется найти численное решение уравнения (2) на интервале $(x_0; x_n)$, которое удовлетворяет начальному условию (3).

Проведём разбиение отрезка $[x_0;x_n]$ на $n$ равных частей[@methods:2018:bash]:

$$
x_i = x_0 + ih,  i = \overline{1,n}
$$
$$
h = \frac{x_n - x_0}{n}
$$

Для вычисления значения функции в точке $x_1$ разложим функцию $y = y(x)$ в окрестности точки $x_0$ в ряд Тейлора:

$$
y(x_1) = y(x_0 + h) = y(x_0) + y'(x_0)h+y''(x_0)\frac{h^2}{2}+\dots
$$

При достаточном малом значении $h$ членами выше второго порядка можно пренебречь и с учетом $y'(x_0) = f(x_0, y_0)$ получим следующую формулу для вычисления приближенного значения функции $y(x)$ в точке $x_1$:
$$
y_2 = y_1+hf(x_1,y_1)
$$

Повторяя этот процесс, сформируем последовательность значений $x_i$ в точках $t_i$ по формуле:
$$
y_{i+1} = y_i + hf(x_i, y_i) \tag{4}
$$

Процесс нахождения значений функции $x_i$ в узловых точках $t_i$ по формуле (3) называется методом Эйлера. Так как точность определяется отброшенными членами ряда, то точность метода Эйлера на каждом шаге составляет $O(h^2)$. в целом точность этого метода $O(h)$.

# Методы Рунге-Кутты

Семейство явных методов Рунге — Кутты задаётся формулами:

$$
 \textbf{y}_{n+1} = \textbf{y}_n + h\sum_{i=1}^n b_i \textbf{k}_i,
$$

$$
\begin{cases}
&\textbf{k}_1 = \textbf{f}(x_n, \textbf{y}_n),\\
&\textbf{k}_2 = \textbf{f}(x_n+c_2h, \textbf{y}_n+a_{21}h\textbf{k}_1),\\
&\dots\\
&\textbf{k}_s = \textbf{f}(x_n+c_sh, \textbf{y}_n+a_{s1}h\textbf{k}_1+a_{s2}h\textbf{k}_2+\cdots+a_{s,s-1}h\textbf{k}_{s-1}).
\end{cases}
$$
Конкретный метод определяется числом $s$ и коэффициентами $b_{i}$, $a_{ij}$ и $c_i$. Эти коэффициенты часто упорядочивают в таблицу Бутчера:
$$

\begin{pmatrix}
  0 &| &&&&\\
  c_2 &|   & a_{21} &&&&\\
  c_3 &|   & a_{31} & a_{32} &&&\\
  \vdots &| & \vdots & \vdots& \ddots&&\\
  c_s &|   & a_{s1} & a_{s2}& \dots & a_{ss-1}&\\
  \hline &| & b_1    & b_2   & \dots & b_{s-1} & b_s
\end{pmatrix}
$$

Для коэффициентов метода Рунге — Кутты должны быть выполнены условия $\sum_{j=1}^{i-1} a_{ij} = c_i$ для  $i=2,\ldots,s$.

Методы Рунге-Кутты имеют ряд достоинтв.
- Позволяют получить приближенное решение с хорошей точностью.
- Являются явнями, то есть значение $y_{n+1}$ вычисляется по ранее найденным значениям за определённое число действий по определённым формулам.
- Допускают расчет переменным шагом, то есть можно уменьшить шаг там, где функция быстро меняется, и увеличить его в обратном случае.


# Решение задачи Коши с помощью программных средств

Рассмотрим задачу Коши:
$$\begin{cases}
&y'(x) = 11y +e^{10x}+x^4+x^3-sin(x)\\
&y(0) = 5 \tag{5}
\end{cases}$$

Известно точное решение задачи (5):

$$y(x) = - \dfrac{x^4}{11} - \dfrac{15x^3}{121} - \dfrac{45x^2}{1331} - \dfrac{90x}{14641} + \dfrac{cos(x)}{122} + \dfrac{11sin(x)}{122} + \dfrac{117739261e^{11x}}{19648222} - e^{10x} -\dfrac{90}{161051}$$

## Решение задачи Коши с помощью Octave

В Octave нет метода Эйлера, однако есть методы Рунге-Кутта

`ode23(@f, interval, X0, options)`, `ode45(@f, interval, X0, options)` --- функции решений обыкновенных нежёстких дифференциальных уравнений (или систем) методом Рунге-Кутта 2-3-го и 4-5-го порядка точности соответственно.

Функции решают систему дифференциальных уравнений, автоматически подбирая шаг для достижения необходимой точности.
Входными параметрами этих функций являются:

- `f` -= вектор-функция для вычисления правой части дифференциального уравнения или системы;
- `interval` -= массив из двух чисел, определяющий интервал интегрирования дифференциального уравнения или системы;
- `X0` -- вектор начальных условий системы дифференциальных систем;
- `option` -- параметры управления ходом решения дифференциального уравнения или системы.

При решении дифференциальных уравнений необходимо определить следующие параметры:
- `RelTol` -- относительная точность решения, значение по умолчанию 10−3;
- `AbsTol` -- абсолютная точность решения, значение по умолчанию 10−3;
- `InitialStep` -- начальное значение шага изменения независимой переменной, значение по умолчанию 0.025;
- `MaxStep` -- максимальное значение шага изменения независимой переменной, значение по умолчанию 0.025.

Все функции возвращают:
- массив T - координат узлов сетки, в которых ищется решение;
- матрицу X, i-й столбец которой является значением вектор-функции решения в узле Тi.

```
clear;

function dydx = f(x,y)
  dydx = y*11 +exp(10*x)+(x^4+x^3)-sin(x);
endfunction

function q = g(x)
 q = -90/161051 - exp(10*x) - 90*x/14641 - 45*x.^2/1331 - 15*x.^3/121 - ...
 -x.^4/11 + cos(x)/122 + 11*sin(x)/122 + 117739261*exp(11*x)/19648222;
endfunction

[X23,Y23]=ode23(@f,[0 0.5],5);
x1=0:0.05:0.5;
y1=g(x1)

plot(x1,y1,'-g;exact solution;',X23,Y23,'*b;ode23;');
grid on;
```

```
clear;

function dydx = f(x,y)
  dydx = y*11 +exp(10*x)+(x^4+x^3)-sin(x);
endfunction

function q = g(x)
 q = -90/161051 - exp(10*x) - 90*x/14641 - 45*x.^2/1331 - 15*x.^3/121 -...
 -x.^4/11 + cos(x)/122 + 11*sin(x)/122 + 117739261*exp(11*x)/19648222;
endfunction

[X45,Y45]=ode45(@f,[0 0.5],5);
x1=0:0.05:0.5;
y1=g(x1)

plot(x1,y1,'-g;exact solution;',X45,Y45,'*b;ode45;');
grid on;
```

## Решение задачи Коши с помощью Julia

Для того чтобы задать ОДУ используется конструктор ODEProblem:

`ODEProblem(f::ODEFunction,u0,tspan,p=NullParameters();kwargs...)`

Входными параметрами этого конструктора являются:

- `f` -- функция в ОДУ;
- `u0` -- начальное состояние;
- `tspan` - временной интервал;
- `р` -- параметры ОДУ;
- `kwargs` -- параметры управления ходом решения.

Функция in-place — f!(du,u,p,t), где возвращаемое значение игнорируется, и ожидается, что результат будет преобразован в значение du. Функция out-place - du=f(u,p,t)

Для решения ОДУ используется функция `solve`, на вход которой подаётся ODEProblem c разными параметрами. Наиболее полезными параметрами являются abstol -- абсолютная точность, reltol -- относительная точность, saveat - шаг метода. По умолчанию abstol=1e-6, reltol=1e-3. Также на вход подаётся метод решения, мы рассмотрим метод BS3() - метод Рунге-Куты 2-го, 3-го порядка, эта функция соответствует ode23() из Matlab и DP5() - метод Рунге-Куты 4-го, 5-го порядка, эта функция соответствует ode45() из Matlab.


abstol: Absolute tolerance in adaptive timestepping. This is the tolerance on local error estimates, not necessarily the global error (though these quantities are related). Defaults to 1e-6 on deterministic equations (ODEs/DDEs/DAEs) and 1e-2 on stochastic equations (SDEs/RODEs).
reltol: Relative tolerance in adaptive timestepping. This is the tolerance on local error estimates, not necessarily the global error (though these quantities are related). Defaults to 1e-3 on deterministic equations (ODEs/DDEs/DAEs) and 1e-2 on stochastic equations (SDEs/RODEs).
dt: Sets the initial stepsize. This is also the stepsize for fixed timestep methods. Defaults to an automatic choice if the method is adaptive.
dtmax: Maximum dt for adaptive timestepping. Defaults are package-dependent.



```
function F!( y, p, x)
 	dydx = x*11+exp(10*x)+(x.^4+x.^3)-sin(x);
end

g(x) = -90/161051 - exp(10*x) - 90*x/14641 - 45*x.^2/1331 - 15*x.^3/121-x.^4/11 + cos(x)/122 + 11*sin(x)/122 + 117739261*exp(11*x)/19648222;
const x = collect(0:0.025:0.5);
y = g.(x)

begin
	x0 = 5.0
	X = (0.0, 0.5)
	prob = ODEProblem(F!, y0, x)
end

sol = solve(prob, BS3(), saveat=0.025);

```
```
function F!( y, p, x)
 	dydx = x*11+exp(10*x)+(x.^4+x.^3)-sin(x);
end

g(x) = -90/161051 - exp(10*x) - 90*x/14641 - 45*x.^2/1331 - 15*x.^3/121-x.^4/11 + cos(x)/122 + 11*sin(x)/122 + 117739261*exp(11*x)/19648222;
const x = collect(0:0.025:0.5);
y = g.(x)

begin
	x0 = 5.0
	X = (0.0, 0.5)
	prob = ODEProblem(F!, y0, x)
end

sol = solve(prob, DP5(), saveat=0.025);

```

## Решение задачи Коши с помощью Python

# Сравнение решений

# Выводы

Здесь кратко описываются итоги проделанной работы.

# Список литературы{.unnumbered}

::: {#refs}
:::
